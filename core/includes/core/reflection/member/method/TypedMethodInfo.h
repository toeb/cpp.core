#pragma once
#include <core/core.h>

#include <core/reflection/member/method/MethodInfo.h>
#include <core/reflection/callable/TypedCallableInfo.h>

NS_BEGIN(CORE_NAMESPACE)


  template<typename Method>
  struct TypedMethodInfo : public MethodInfo , public TypedCallableInfo<Method>{

    using MethodInfo::argument;
    TypedMethodInfo(Method method):TypedCallableInfo<Method>(method){}
    Argument callImplementation(const ArgumentList & args)const{
      return TypedCallableInfo<Method>::callImplementation(args);
    }
  };

  
  template<typename Method>
  auto method_info_shared(Method method)->std::shared_ptr<NS(CORE_NAMESPACE)::TypedMethodInfo<Method>>{
    return std::make_shared<NS(CORE_NAMESPACE)::TypedMethodInfo<Method>>(method);
  }

  /*
  template<typename ClassType, typename ReturnType>
  struct TypedMethodInfo<ReturnType(ClassType::*)()const>:public MethodInfo{
    typedef ReturnType(ClassType::*MethodType)()const ;                                                   
    MethodType method;                                                                                                                        
    TypedMethodInfo(MethodType method):method(method){    
      setOwningType(type_of<ClassType>());
      setReturnType(type_of<ReturnType>());
      setIsConst(true);
    }                                                                                       
    Argument typedCall(const ClassType * object, std::vector<Argument> args)const{                                                                       
      return Argument(((*object).*method)()); 
    }
    Argument call(const void * object, std::vector<Argument> args )const{                                                                                
      return typedCall(static_cast<const ClassType*>(object),args);                                                                                   
    }                                    
    
  };

  template<typename ClassType, typename ReturnType>
  struct TypedMethodInfo<ReturnType(ClassType::*)()>:public MethodInfo{
    typedef ReturnType(ClassType::*MethodType)() ;                                                   
    MethodType method;                                                                                                                        
    TypedMethodInfo(MethodType method):method(method){
      setOwningType(type_of<ClassType>());
      setReturnType(type_of<ReturnType>());
      setIsConst(false);
    }                                                                                       
    Argument typedCall(ClassType * object, std::vector<Argument> args)const{                                                                       
      Argument result;                                                                                                                           
      return Argument(((*object).*method)()); 
    }                                                                                                                                         
    Argument call(void * object, std::vector<Argument> args )const{                                                                                
      return typedCall(static_cast<ClassType*>(object),args);                                                                                   
    }                                                                
  };

  template<typename ClassType>
  struct TypedMethodInfo<void(ClassType::*)()const>:public MethodInfo{
    typedef void(ClassType::*MethodType)()const ;           
    MethodType method;                                                                                                                        
    TypedMethodInfo(MethodType method):method(method){
      setOwningType(type_of<ClassType>());
      setReturnType(type_of<void>());
      setIsConst(true);
    }                                                                                       
    Argument typedCall(const ClassType * object, std::vector<Argument> args)const{           
      ((*object).*method)(); 
      return Argument::VoidArgument();
    }                                                                                                                                         
    Argument call(const void * object, std::vector<Argument> args )const{                                                                                
      return typedCall(static_cast<const ClassType*>(object),args);                                                                                   
    }                                                                
  };
  template<typename ClassType>
  struct TypedMethodInfo<void(ClassType::*)()>:public MethodInfo{
    typedef void(ClassType::*MethodType)() ;                                                   
    MethodType method;                                                                                                                        
    TypedMethodInfo(MethodType method):method(method){
      setOwningType(type_of<ClassType>());
      setReturnType(type_of<void>());
      setIsConst(false);
    }                                                                                       
    Argument typedCall(ClassType * object, std::vector<Argument> args)const{           
      ((*object).*method)(); 
      return Argument::VoidArgument();
    }                                                                                                                                         
    Argument call(void * object, std::vector<Argument> args )const{                                                                                
      return typedCall(static_cast<ClassType*>(object),args);                                                                                   
    }                                                                
  };
  */
  
#define DS_TYPED_METHOD_INFO_ADD_ARGUMENT_INFO(X) Arguments().push_back(std::make_shared<TypedArgumentInfo<typename DS_CONCAT(ArgumentType_,X),X>>());
#define DS_TYPED_METHOD_INFO_ARGUMENT_TYPEDEF(X) typedef typename std::decay<typename traits::nested_template arg<X>::type>::type DS_CONCAT(ArgumentType_,X);
  // the following code creates specializations for methods with up to 9 arguments
#define DS_TYPED_METHOD_INFO_ADD_ARGUMENT(X) argumentTypes().push_back(type_of<X>());
#define DS_TYPED_METHOD_INFO_PASS_ARG(X) (DS_CONCAT(ArgumentType_,X)) args[X]
#define DS_TYPED_METHOD_INFO_CHECK_ARG(X) if(!args[X].isValid())return Argument();
#define DS_TYPED_METHOD_INFO_CALL_METHOD(...) ((*object).*method)(DS_REDUCE_COMMA(DS_TYPED_METHOD_INFO_PASS_ARG,DS_SEQUENCE(DS_MINUS_ONE(DS_NUM_ARGS(__VA_ARGS__)))))
#define DS_TYPED_METHOD_INFO(...)                                                                                                            \
  /* Specialization for const method with non void return type and arbirtray arguments*/                                                     \
  template<typename ClassType, typename ReturnType,DS_REDUCE_COMMA(DS_ADD_TYPENAME,__VA_ARGS__)>                                             \
  struct TypedMethodInfo<ReturnType(ClassType::*)(DS_REDUCE_COMMA(DS_NOOP,__VA_ARGS__)) const>:public MethodInfo{                            \
  typedef ReturnType(ClassType::*MethodType)(DS_REDUCE_COMMA(DS_NOOP,__VA_ARGS__))const ;                                                    \
  MethodType method;                                                                                                                         \
  typedef function_traits<MethodType> traits;                                                                                                \
  DS_FOREACH(DS_TYPED_METHOD_INFO_ARGUMENT_TYPEDEF,DS_SEQUENCE(DS_MINUS_ONE(DS_NUM_ARGS(__VA_ARGS__))))                                      \
  /* Constrcutor*/                                                                                                                           \
  TypedMethodInfo(MethodType method):method(method){                                                                                         \
  setOwningType(type_of<ClassType>());                                                                                                       \
  setReturnType(type_of<ReturnType>());                                                                                                      \
  DS_FOREACH(DS_TYPED_METHOD_INFO_ADD_ARGUMENT,__VA_ARGS__)                                                                                  \
  DS_FOREACH(DS_TYPED_METHOD_INFO_ADD_ARGUMENT_INFO,DS_SEQUENCE(DS_MINUS_ONE(DS_NUM_ARGS(__VA_ARGS__))))                                      \
  setIsConst(true);                                                                                                                          \
  }                                                                                                                                          \
  Argument typedCall(const ClassType * object, std::vector<Argument> args)const{                                                             \
  DS_FOREACH(DS_TYPED_METHOD_INFO_CHECK_ARG, DS_SEQUENCE(DS_MINUS_ONE(DS_NUM_ARGS(__VA_ARGS__))))                                            \
  return Argument(DS_TYPED_METHOD_INFO_CALL_METHOD(__VA_ARGS__));                                                                            \
  }                                                                                                                                          \
  Argument call(const void * object, std::vector<Argument> args )const{                                                                      \
  return typedCall(static_cast<const ClassType*>(object),args);                                                                              \
  }                                                                                                                                          \
  };                                                                                                                                         \
  /* Specialization for non-const method with non void return type and arbitrary arguments*/                                                 \
  template<typename ClassType, typename ReturnType,DS_REDUCE_COMMA(DS_ADD_TYPENAME,__VA_ARGS__)>                                             \
  struct TypedMethodInfo<ReturnType(ClassType::*)(DS_REDUCE_COMMA(DS_NOOP,__VA_ARGS__))>:public MethodInfo{                                  \
  typedef ReturnType(ClassType::*MethodType)(DS_REDUCE_COMMA(DS_NOOP,__VA_ARGS__));                                                          \
  MethodType method;                                                                                                                         \
  typedef function_traits<MethodType> traits;                                                                                                \
  DS_FOREACH(DS_TYPED_METHOD_INFO_ARGUMENT_TYPEDEF,DS_SEQUENCE(DS_MINUS_ONE(DS_NUM_ARGS(__VA_ARGS__))))                                      \
  TypedMethodInfo(MethodType method):method(method){                                                                                         \
  setOwningType(type_of<ClassType>());                                                                                                       \
  setReturnType(type_of<ReturnType>());                                                                                                      \
  DS_FOREACH(DS_TYPED_METHOD_INFO_ADD_ARGUMENT,__VA_ARGS__)                                                                                  \
  DS_FOREACH(DS_TYPED_METHOD_INFO_ADD_ARGUMENT_INFO,DS_SEQUENCE(DS_MINUS_ONE(DS_NUM_ARGS(__VA_ARGS__))))                                      \
  setIsConst(false);                                                                                                                         \
  }                                                                                                                                          \
  Argument typedCall(ClassType * object, std::vector<Argument> args)const{                                                                   \
  DS_FOREACH(DS_TYPED_METHOD_INFO_CHECK_ARG, DS_SEQUENCE(DS_MINUS_ONE(DS_NUM_ARGS(__VA_ARGS__))))                                            \
  return Argument(DS_TYPED_METHOD_INFO_CALL_METHOD(__VA_ARGS__));                                                                            \
  }                                                                                                                                          \
  Argument call(void * object, std::vector<Argument> args )const{                                                                            \
  return typedCall(static_cast<ClassType*>(object),args);                                                                                    \
  }                                                                                                                                          \
  };                                                                                                                                         \
  /* Specialization for const method with  void return type and arbirtray arguments*/                                                        \
  template<typename ClassType,DS_REDUCE_COMMA(DS_ADD_TYPENAME,__VA_ARGS__)>                                                                  \
  struct TypedMethodInfo<void(ClassType::*)(DS_REDUCE_COMMA(DS_NOOP,__VA_ARGS__))const>:public MethodInfo{                                   \
  typedef void(ClassType::*MethodType)(DS_REDUCE_COMMA(DS_NOOP,__VA_ARGS__))const ;                                                          \
  MethodType method;                                                                                                                         \
  typedef function_traits<MethodType> traits;                                                                                                \
  DS_FOREACH(DS_TYPED_METHOD_INFO_ARGUMENT_TYPEDEF,DS_SEQUENCE(DS_MINUS_ONE(DS_NUM_ARGS(__VA_ARGS__))))                                      \
  TypedMethodInfo(MethodType method):method(method){                                                                                         \
  setOwningType(type_of<ClassType>());                                                                                                       \
  setReturnType(type_of<void>());                                                                                                            \
  DS_FOREACH(DS_TYPED_METHOD_INFO_ADD_ARGUMENT,__VA_ARGS__)                                                                                  \
  setIsConst(true);                                                                                                                          \
  }                                                                                                                                          \
  Argument typedCall(const ClassType * object, std::vector<Argument> args)const{                                                             \
  DS_FOREACH(DS_TYPED_METHOD_INFO_CHECK_ARG, DS_SEQUENCE(DS_MINUS_ONE(DS_NUM_ARGS(__VA_ARGS__))))                                            \
  DS_TYPED_METHOD_INFO_CALL_METHOD(__VA_ARGS__);                                                                                             \
  return Argument::VoidArgument();                                                                                                           \
  }                                                                                                                                          \
  Argument call(const void * object, std::vector<Argument> args )const{                                                                      \
  return typedCall(static_cast<const ClassType*>(object),args);                                                                              \
  }                                                                                                                                          \
  };                                                                                                                                         \
  /* Specialization for non-const method with void return type and arbirtray arguments*/                                                     \
  template<typename ClassType,DS_REDUCE_COMMA(DS_ADD_TYPENAME,__VA_ARGS__)>                                                                  \
  struct TypedMethodInfo<void(ClassType::*)(DS_REDUCE_COMMA(DS_NOOP,__VA_ARGS__))>:public MethodInfo{                                        \
  typedef void(ClassType::*MethodType)(DS_REDUCE_COMMA(DS_NOOP,__VA_ARGS__)) ;                                                               \
  MethodType method;                                                                                                                         \
  typedef function_traits<MethodType> traits;                                                                                                \
  DS_FOREACH(DS_TYPED_METHOD_INFO_ARGUMENT_TYPEDEF,DS_SEQUENCE(DS_MINUS_ONE(DS_NUM_ARGS(__VA_ARGS__))))                                      \
  TypedMethodInfo(MethodType method):method(method){                                                                                         \
  setOwningType(type_of<ClassType>());                                                                                                       \
  setReturnType(type_of<void>());                                                                                                            \
  DS_FOREACH(DS_TYPED_METHOD_INFO_ADD_ARGUMENT,__VA_ARGS__)                                                                                  \
  setIsConst(false);                                                                                                                         \
  }                                                                                                                                          \
  Argument typedCall(ClassType * object, std::vector<Argument> args)const{                                                                   \
  DS_FOREACH(DS_TYPED_METHOD_INFO_CHECK_ARG, DS_SEQUENCE(DS_MINUS_ONE(DS_NUM_ARGS(__VA_ARGS__))))                                            \
  DS_TYPED_METHOD_INFO_CALL_METHOD(__VA_ARGS__);                                                                                             \
  return Argument::VoidArgument();                                                                                                           \
  }                                                                                                                                          \
  Argument call(void * object, std::vector<Argument> args )const{                                                                            \
  return typedCall(static_cast<ClassType*>(object),args);                                                                                    \
  }                                                                                                                                          \
  };      


  // define specialization for upt o 9 arguments.  

/*
#define DS_FOR_N_TEMPLATE_ARGS(M,N) DS_FOREACH(DS_TYPED_METHOD_INFO, DS_REDUCE_COMMA(DS_ARG_NAME,DS_SEQUENCE(N)))
#define DS_FOR_ALL_TEMPLATE_ARGS(M) DS_FOR_N_TEMPLATE_ARGS(M,DS_PREPROCESSOR_ARG_COUNT)



DS_FOR_N_TEMPLATE_ARGS(DS_TYPED_METHOD_INFO)
*/

 /*
 DS_TYPED_METHOD_INFO(A1)
  DS_TYPED_METHOD_INFO(A1,A2)
  DS_TYPED_METHOD_INFO(A1,A2,A3)
  DS_TYPED_METHOD_INFO(A1,A2,A3,A4)
  DS_TYPED_METHOD_INFO(A1,A2,A3,A4,A5)
  DS_TYPED_METHOD_INFO(A1,A2,A3,A4,A5,A6)
  DS_TYPED_METHOD_INFO(A1,A2,A3,A4,A5,A6,A7)
  DS_TYPED_METHOD_INFO(A1,A2,A3,A4,A5,A6,A7,A8)
  DS_TYPED_METHOD_INFO(A1,A2,A3,A4,A5,A6,A7,A8,A9)
  */


/*
  template<typename ClassType, typename ReturnType,typename A1>
  struct TypedMethodInfo<ReturnType(ClassType::*)(A1) const>:public MethodInfo{ 
    typedef ReturnType(ClassType::*MethodType)(A1)const ;
    MethodType method; 
    typedef function_traits<MethodType> traits; 
    typedef typename std::decay<typename traits::template arg<0>::type>::type ArgumentType_0; 
    TypedMethodInfo(MethodType method):method(method){
      setOwningType(type_of<ClassType>()); 
      setReturnType(type_of<ReturnType>());
      argumentTypes().push_back(type_of<A1>()); 
      setIsConst(true);
    }
    Argument typedCall(const ClassType * object, std::vector<Argument> args)const{
      if(!args[0].isValid())return Argument(); 
      return Argument(((*object).*method)((ArgumentType_0) args[0]));
    } 
    Argument call(const void * object, std::vector<Argument> args )const{
      return typedCall(static_cast<const ClassType*>(object),args);
    }
  }; 
  template<typename ClassType, typename ReturnType,typename A1> struct TypedMethodInfo<ReturnType(ClassType::*)(A1)>:public MethodInfo{ typedef ReturnType(ClassType::*MethodType)(A1); MethodType method; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<ReturnType>()); argumentTypes().push_back(type_of<A1>()); setIsConst(false); } Argument typedCall(ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); return Argument(((*object).*method)((ArgumentType_0) args[0])); } Argument call(void * object, std::vector<Argument> args )const{ return typedCall(static_cast<ClassType*>(object),args); } }; template<typename ClassType,typename A1> struct TypedMethodInfo<void(ClassType::*)(A1)const>:public MethodInfo{ typedef void(ClassType::*MethodType)(A1)const ; MethodType method; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<void>()); argumentTypes().push_back(type_of<A1>()); setIsConst(true); } Argument typedCall(const ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); ((*object).*method)((ArgumentType_0) args[0]); return Argument::VoidArgument(); } Argument call(const void * object, std::vector<Argument> args )const{ return typedCall(static_cast<const ClassType*>(object),args); } }; template<typename ClassType,typename A1> struct TypedMethodInfo<void(ClassType::*)(A1)>:public MethodInfo{ typedef void(ClassType::*MethodType)(A1) ; MethodType method; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<void>()); argumentTypes().push_back(type_of<A1>()); setIsConst(false); } Argument typedCall(ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); ((*object).*method)((ArgumentType_0) args[0]); return Argument::VoidArgument(); } Argument call(void * object, std::vector<Argument> args )const{ return typedCall(static_cast<ClassType*>(object),args); } };
  template<typename ClassType, typename ReturnType,typename A1, typename A2> struct TypedMethodInfo<ReturnType(ClassType::*)(A1, A2) const>:public MethodInfo{ typedef ReturnType(ClassType::*MethodType)(A1, A2)const ; MethodType method; typedef function_traits<MethodType> traits; typedef typename std::decay<typename traits::template arg<0>::type>::type ArgumentType_0; typedef typename std::decay<typename traits::template arg<1>::type>::type ArgumentType_1; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<ReturnType>()); argumentTypes().push_back(type_of<A1>()); argumentTypes().push_back(type_of<A2>()); setIsConst(true); } Argument typedCall(const ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); if(!args[1].isValid())return Argument(); return Argument(((*object).*method)((ArgumentType_0) args[0], (ArgumentType_1) args[1])); } Argument call(const void * object, std::vector<Argument> args )const{ return typedCall(static_cast<const ClassType*>(object),args); } }; template<typename ClassType, typename ReturnType,typename A1, typename A2> struct TypedMethodInfo<ReturnType(ClassType::*)(A1, A2)>:public MethodInfo{ typedef ReturnType(ClassType::*MethodType)(A1, A2); MethodType method; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<ReturnType>()); argumentTypes().push_back(type_of<A1>()); argumentTypes().push_back(type_of<A2>()); setIsConst(false); } Argument typedCall(ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); if(!args[1].isValid())return Argument(); return Argument(((*object).*method)((ArgumentType_0) args[0], (ArgumentType_1) args[1])); } Argument call(void * object, std::vector<Argument> args )const{ return typedCall(static_cast<ClassType*>(object),args); } }; template<typename ClassType,typename A1, typename A2> struct TypedMethodInfo<void(ClassType::*)(A1, A2)const>:public MethodInfo{ typedef void(ClassType::*MethodType)(A1, A2)const ; MethodType method; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<void>()); argumentTypes().push_back(type_of<A1>()); argumentTypes().push_back(type_of<A2>()); setIsConst(true); } Argument typedCall(const ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); if(!args[1].isValid())return Argument(); ((*object).*method)((ArgumentType_0) args[0], (ArgumentType_1) args[1]); return Argument::VoidArgument(); } Argument call(const void * object, std::vector<Argument> args )const{ return typedCall(static_cast<const ClassType*>(object),args); } }; template<typename ClassType,typename A1, typename A2> struct TypedMethodInfo<void(ClassType::*)(A1, A2)>:public MethodInfo{ typedef void(ClassType::*MethodType)(A1, A2) ; MethodType method; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<void>()); argumentTypes().push_back(type_of<A1>()); argumentTypes().push_back(type_of<A2>()); setIsConst(false); } Argument typedCall(ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); if(!args[1].isValid())return Argument(); ((*object).*method)((ArgumentType_0) args[0], (ArgumentType_1) args[1]); return Argument::VoidArgument(); } Argument call(void * object, std::vector<Argument> args )const{ return typedCall(static_cast<ClassType*>(object),args); } };
  template<typename ClassType, typename ReturnType,typename A1, typename A2, typename A3> struct TypedMethodInfo<ReturnType(ClassType::*)(A1, A2, A3) const>:public MethodInfo{ typedef ReturnType(ClassType::*MethodType)(A1, A2, A3)const ; MethodType method; typedef function_traits<MethodType> traits; typedef typename std::decay<typename traits::template arg<0>::type>::type ArgumentType_0; typedef typename std::decay<typename traits::template arg<1>::type>::type ArgumentType_1; typedef typename std::decay<typename traits::template arg<2>::type>::type ArgumentType_2; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<ReturnType>()); argumentTypes().push_back(type_of<A1>()); argumentTypes().push_back(type_of<A2>()); argumentTypes().push_back(type_of<A3>()); setIsConst(true); } Argument typedCall(const ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); if(!args[1].isValid())return Argument(); if(!args[2].isValid())return Argument(); return Argument(((*object).*method)((ArgumentType_0) args[0], (ArgumentType_1) args[1], (ArgumentType_2) args[2])); } Argument call(const void * object, std::vector<Argument> args )const{ return typedCall(static_cast<const ClassType*>(object),args); } }; template<typename ClassType, typename ReturnType,typename A1, typename A2, typename A3> struct TypedMethodInfo<ReturnType(ClassType::*)(A1, A2, A3)>:public MethodInfo{ typedef ReturnType(ClassType::*MethodType)(A1, A2, A3); MethodType method; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<ReturnType>()); argumentTypes().push_back(type_of<A1>()); argumentTypes().push_back(type_of<A2>()); argumentTypes().push_back(type_of<A3>()); setIsConst(false); } Argument typedCall(ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); if(!args[1].isValid())return Argument(); if(!args[2].isValid())return Argument(); return Argument(((*object).*method)((ArgumentType_0) args[0], (ArgumentType_1) args[1], (ArgumentType_2) args[2])); } Argument call(void * object, std::vector<Argument> args )const{ return typedCall(static_cast<ClassType*>(object),args); } }; template<typename ClassType,typename A1, typename A2, typename A3> struct TypedMethodInfo<void(ClassType::*)(A1, A2, A3)const>:public MethodInfo{ typedef void(ClassType::*MethodType)(A1, A2, A3)const ; MethodType method; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<void>()); argumentTypes().push_back(type_of<A1>()); argumentTypes().push_back(type_of<A2>()); argumentTypes().push_back(type_of<A3>()); setIsConst(true); } Argument typedCall(const ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); if(!args[1].isValid())return Argument(); if(!args[2].isValid())return Argument(); ((*object).*method)((ArgumentType_0) args[0], (ArgumentType_1) args[1], (ArgumentType_2) args[2]); return Argument::VoidArgument(); } Argument call(const void * object, std::vector<Argument> args )const{ return typedCall(static_cast<const ClassType*>(object),args); } }; template<typename ClassType,typename A1, typename A2, typename A3> struct TypedMethodInfo<void(ClassType::*)(A1, A2, A3)>:public MethodInfo{ typedef void(ClassType::*MethodType)(A1, A2, A3) ; MethodType method; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<void>()); argumentTypes().push_back(type_of<A1>()); argumentTypes().push_back(type_of<A2>()); argumentTypes().push_back(type_of<A3>()); setIsConst(false); } Argument typedCall(ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); if(!args[1].isValid())return Argument(); if(!args[2].isValid())return Argument(); ((*object).*method)((ArgumentType_0) args[0], (ArgumentType_1) args[1], (ArgumentType_2) args[2]); return Argument::VoidArgument(); } Argument call(void * object, std::vector<Argument> args )const{ return typedCall(static_cast<ClassType*>(object),args); } };
  template<typename ClassType, typename ReturnType,typename A1, typename A2, typename A3, typename A4> struct TypedMethodInfo<ReturnType(ClassType::*)(A1, A2, A3, A4) const>:public MethodInfo{ typedef ReturnType(ClassType::*MethodType)(A1, A2, A3, A4)const ; MethodType method; typedef function_traits<MethodType> traits; typedef typename std::decay<typename traits::template arg<0>::type>::type ArgumentType_0; typedef typename std::decay<typename traits::template arg<1>::type>::type ArgumentType_1; typedef typename std::decay<typename traits::template arg<2>::type>::type ArgumentType_2; typedef typename std::decay<typename traits::template arg<3>::type>::type ArgumentType_3; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<ReturnType>()); argumentTypes().push_back(type_of<A1>()); argumentTypes().push_back(type_of<A2>()); argumentTypes().push_back(type_of<A3>()); argumentTypes().push_back(type_of<A4>()); setIsConst(true); } Argument typedCall(const ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); if(!args[1].isValid())return Argument(); if(!args[2].isValid())return Argument(); if(!args[3].isValid())return Argument(); return Argument(((*object).*method)((ArgumentType_0) args[0], (ArgumentType_1) args[1], (ArgumentType_2) args[2], (ArgumentType_3) args[3])); } Argument call(const void * object, std::vector<Argument> args )const{ return typedCall(static_cast<const ClassType*>(object),args); } }; template<typename ClassType, typename ReturnType,typename A1, typename A2, typename A3, typename A4> struct TypedMethodInfo<ReturnType(ClassType::*)(A1, A2, A3, A4)>:public MethodInfo{ typedef ReturnType(ClassType::*MethodType)(A1, A2, A3, A4); MethodType method; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<ReturnType>()); argumentTypes().push_back(type_of<A1>()); argumentTypes().push_back(type_of<A2>()); argumentTypes().push_back(type_of<A3>()); argumentTypes().push_back(type_of<A4>()); setIsConst(false); } Argument typedCall(ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); if(!args[1].isValid())return Argument(); if(!args[2].isValid())return Argument(); if(!args[3].isValid())return Argument(); return Argument(((*object).*method)((ArgumentType_0) args[0], (ArgumentType_1) args[1], (ArgumentType_2) args[2], (ArgumentType_3) args[3])); } Argument call(void * object, std::vector<Argument> args )const{ return typedCall(static_cast<ClassType*>(object),args); } }; template<typename ClassType,typename A1, typename A2, typename A3, typename A4> struct TypedMethodInfo<void(ClassType::*)(A1, A2, A3, A4)const>:public MethodInfo{ typedef void(ClassType::*MethodType)(A1, A2, A3, A4)const ; MethodType method; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<void>()); argumentTypes().push_back(type_of<A1>()); argumentTypes().push_back(type_of<A2>()); argumentTypes().push_back(type_of<A3>()); argumentTypes().push_back(type_of<A4>()); setIsConst(true); } Argument typedCall(const ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); if(!args[1].isValid())return Argument(); if(!args[2].isValid())return Argument(); if(!args[3].isValid())return Argument(); ((*object).*method)((ArgumentType_0) args[0], (ArgumentType_1) args[1], (ArgumentType_2) args[2], (ArgumentType_3) args[3]); return Argument::VoidArgument(); } Argument call(const void * object, std::vector<Argument> args )const{ return typedCall(static_cast<const ClassType*>(object),args); } }; template<typename ClassType,typename A1, typename A2, typename A3, typename A4> struct TypedMethodInfo<void(ClassType::*)(A1, A2, A3, A4)>:public MethodInfo{ typedef void(ClassType::*MethodType)(A1, A2, A3, A4) ; MethodType method; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<void>()); argumentTypes().push_back(type_of<A1>()); argumentTypes().push_back(type_of<A2>()); argumentTypes().push_back(type_of<A3>()); argumentTypes().push_back(type_of<A4>()); setIsConst(false); } Argument typedCall(ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); if(!args[1].isValid())return Argument(); if(!args[2].isValid())return Argument(); if(!args[3].isValid())return Argument(); ((*object).*method)((ArgumentType_0) args[0], (ArgumentType_1) args[1], (ArgumentType_2) args[2], (ArgumentType_3) args[3]); return Argument::VoidArgument(); } Argument call(void * object, std::vector<Argument> args )const{ return typedCall(static_cast<ClassType*>(object),args); } };
  template<typename ClassType, typename ReturnType,typename A1, typename A2, typename A3, typename A4, typename A5> struct TypedMethodInfo<ReturnType(ClassType::*)(A1, A2, A3, A4, A5) const>:public MethodInfo{ typedef ReturnType(ClassType::*MethodType)(A1, A2, A3, A4, A5)const ; MethodType method; typedef function_traits<MethodType> traits; typedef typename std::decay<typename traits::template arg<0>::type>::type ArgumentType_0; typedef typename std::decay<typename traits::template arg<1>::type>::type ArgumentType_1; typedef typename std::decay<typename traits::template arg<2>::type>::type ArgumentType_2; typedef typename std::decay<typename traits::template arg<3>::type>::type ArgumentType_3; typedef typename std::decay<typename traits::template arg<4>::type>::type ArgumentType_4; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<ReturnType>()); argumentTypes().push_back(type_of<A1>()); argumentTypes().push_back(type_of<A2>()); argumentTypes().push_back(type_of<A3>()); argumentTypes().push_back(type_of<A4>()); argumentTypes().push_back(type_of<A5>()); setIsConst(true); } Argument typedCall(const ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); if(!args[1].isValid())return Argument(); if(!args[2].isValid())return Argument(); if(!args[3].isValid())return Argument(); if(!args[4].isValid())return Argument(); return Argument(((*object).*method)((ArgumentType_0) args[0], (ArgumentType_1) args[1], (ArgumentType_2) args[2], (ArgumentType_3) args[3], (ArgumentType_4) args[4])); } Argument call(const void * object, std::vector<Argument> args )const{ return typedCall(static_cast<const ClassType*>(object),args); } }; template<typename ClassType, typename ReturnType,typename A1, typename A2, typename A3, typename A4, typename A5> struct TypedMethodInfo<ReturnType(ClassType::*)(A1, A2, A3, A4, A5)>:public MethodInfo{ typedef ReturnType(ClassType::*MethodType)(A1, A2, A3, A4, A5); MethodType method; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<ReturnType>()); argumentTypes().push_back(type_of<A1>()); argumentTypes().push_back(type_of<A2>()); argumentTypes().push_back(type_of<A3>()); argumentTypes().push_back(type_of<A4>()); argumentTypes().push_back(type_of<A5>()); setIsConst(false); } Argument typedCall(ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); if(!args[1].isValid())return Argument(); if(!args[2].isValid())return Argument(); if(!args[3].isValid())return Argument(); if(!args[4].isValid())return Argument(); return Argument(((*object).*method)((ArgumentType_0) args[0], (ArgumentType_1) args[1], (ArgumentType_2) args[2], (ArgumentType_3) args[3], (ArgumentType_4) args[4])); } Argument call(void * object, std::vector<Argument> args )const{ return typedCall(static_cast<ClassType*>(object),args); } }; template<typename ClassType,typename A1, typename A2, typename A3, typename A4, typename A5> struct TypedMethodInfo<void(ClassType::*)(A1, A2, A3, A4, A5)const>:public MethodInfo{ typedef void(ClassType::*MethodType)(A1, A2, A3, A4, A5)const ; MethodType method; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<void>()); argumentTypes().push_back(type_of<A1>()); argumentTypes().push_back(type_of<A2>()); argumentTypes().push_back(type_of<A3>()); argumentTypes().push_back(type_of<A4>()); argumentTypes().push_back(type_of<A5>()); setIsConst(true); } Argument typedCall(const ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); if(!args[1].isValid())return Argument(); if(!args[2].isValid())return Argument(); if(!args[3].isValid())return Argument(); if(!args[4].isValid())return Argument(); ((*object).*method)((ArgumentType_0) args[0], (ArgumentType_1) args[1], (ArgumentType_2) args[2], (ArgumentType_3) args[3], (ArgumentType_4) args[4]); return Argument::VoidArgument(); } Argument call(const void * object, std::vector<Argument> args )const{ return typedCall(static_cast<const ClassType*>(object),args); } }; template<typename ClassType,typename A1, typename A2, typename A3, typename A4, typename A5> struct TypedMethodInfo<void(ClassType::*)(A1, A2, A3, A4, A5)>:public MethodInfo{ typedef void(ClassType::*MethodType)(A1, A2, A3, A4, A5) ; MethodType method; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<void>()); argumentTypes().push_back(type_of<A1>()); argumentTypes().push_back(type_of<A2>()); argumentTypes().push_back(type_of<A3>()); argumentTypes().push_back(type_of<A4>()); argumentTypes().push_back(type_of<A5>()); setIsConst(false); } Argument typedCall(ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); if(!args[1].isValid())return Argument(); if(!args[2].isValid())return Argument(); if(!args[3].isValid())return Argument(); if(!args[4].isValid())return Argument(); ((*object).*method)((ArgumentType_0) args[0], (ArgumentType_1) args[1], (ArgumentType_2) args[2], (ArgumentType_3) args[3], (ArgumentType_4) args[4]); return Argument::VoidArgument(); } Argument call(void * object, std::vector<Argument> args )const{ return typedCall(static_cast<ClassType*>(object),args); } };
  template<typename ClassType, typename ReturnType,typename A1, typename A2, typename A3, typename A4, typename A5, typename A6> struct TypedMethodInfo<ReturnType(ClassType::*)(A1, A2, A3, A4, A5, A6) const>:public MethodInfo{ typedef ReturnType(ClassType::*MethodType)(A1, A2, A3, A4, A5, A6)const ; MethodType method; typedef function_traits<MethodType> traits; typedef typename std::decay<typename traits::template arg<0>::type>::type ArgumentType_0; typedef typename std::decay<typename traits::template arg<1>::type>::type ArgumentType_1; typedef typename std::decay<typename traits::template arg<2>::type>::type ArgumentType_2; typedef typename std::decay<typename traits::template arg<3>::type>::type ArgumentType_3; typedef typename std::decay<typename traits::template arg<4>::type>::type ArgumentType_4; typedef typename std::decay<typename traits::template arg<5>::type>::type ArgumentType_5; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<ReturnType>()); argumentTypes().push_back(type_of<A1>()); argumentTypes().push_back(type_of<A2>()); argumentTypes().push_back(type_of<A3>()); argumentTypes().push_back(type_of<A4>()); argumentTypes().push_back(type_of<A5>()); argumentTypes().push_back(type_of<A6>()); setIsConst(true); } Argument typedCall(const ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); if(!args[1].isValid())return Argument(); if(!args[2].isValid())return Argument(); if(!args[3].isValid())return Argument(); if(!args[4].isValid())return Argument(); if(!args[5].isValid())return Argument(); return Argument(((*object).*method)((ArgumentType_0) args[0], (ArgumentType_1) args[1], (ArgumentType_2) args[2], (ArgumentType_3) args[3], (ArgumentType_4) args[4], (ArgumentType_5) args[5])); } Argument call(const void * object, std::vector<Argument> args )const{ return typedCall(static_cast<const ClassType*>(object),args); } }; template<typename ClassType, typename ReturnType,typename A1, typename A2, typename A3, typename A4, typename A5, typename A6> struct TypedMethodInfo<ReturnType(ClassType::*)(A1, A2, A3, A4, A5, A6)>:public MethodInfo{ typedef ReturnType(ClassType::*MethodType)(A1, A2, A3, A4, A5, A6); MethodType method; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<ReturnType>()); argumentTypes().push_back(type_of<A1>()); argumentTypes().push_back(type_of<A2>()); argumentTypes().push_back(type_of<A3>()); argumentTypes().push_back(type_of<A4>()); argumentTypes().push_back(type_of<A5>()); argumentTypes().push_back(type_of<A6>()); setIsConst(false); } Argument typedCall(ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); if(!args[1].isValid())return Argument(); if(!args[2].isValid())return Argument(); if(!args[3].isValid())return Argument(); if(!args[4].isValid())return Argument(); if(!args[5].isValid())return Argument(); return Argument(((*object).*method)((ArgumentType_0) args[0], (ArgumentType_1) args[1], (ArgumentType_2) args[2], (ArgumentType_3) args[3], (ArgumentType_4) args[4], (ArgumentType_5) args[5])); } Argument call(void * object, std::vector<Argument> args )const{ return typedCall(static_cast<ClassType*>(object),args); } }; template<typename ClassType,typename A1, typename A2, typename A3, typename A4, typename A5, typename A6> struct TypedMethodInfo<void(ClassType::*)(A1, A2, A3, A4, A5, A6)const>:public MethodInfo{ typedef void(ClassType::*MethodType)(A1, A2, A3, A4, A5, A6)const ; MethodType method; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<void>()); argumentTypes().push_back(type_of<A1>()); argumentTypes().push_back(type_of<A2>()); argumentTypes().push_back(type_of<A3>()); argumentTypes().push_back(type_of<A4>()); argumentTypes().push_back(type_of<A5>()); argumentTypes().push_back(type_of<A6>()); setIsConst(true); } Argument typedCall(const ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); if(!args[1].isValid())return Argument(); if(!args[2].isValid())return Argument(); if(!args[3].isValid())return Argument(); if(!args[4].isValid())return Argument(); if(!args[5].isValid())return Argument(); ((*object).*method)((ArgumentType_0) args[0], (ArgumentType_1) args[1], (ArgumentType_2) args[2], (ArgumentType_3) args[3], (ArgumentType_4) args[4], (ArgumentType_5) args[5]); return Argument::VoidArgument(); } Argument call(const void * object, std::vector<Argument> args )const{ return typedCall(static_cast<const ClassType*>(object),args); } }; template<typename ClassType,typename A1, typename A2, typename A3, typename A4, typename A5, typename A6> struct TypedMethodInfo<void(ClassType::*)(A1, A2, A3, A4, A5, A6)>:public MethodInfo{ typedef void(ClassType::*MethodType)(A1, A2, A3, A4, A5, A6) ; MethodType method; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<void>()); argumentTypes().push_back(type_of<A1>()); argumentTypes().push_back(type_of<A2>()); argumentTypes().push_back(type_of<A3>()); argumentTypes().push_back(type_of<A4>()); argumentTypes().push_back(type_of<A5>()); argumentTypes().push_back(type_of<A6>()); setIsConst(false); } Argument typedCall(ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); if(!args[1].isValid())return Argument(); if(!args[2].isValid())return Argument(); if(!args[3].isValid())return Argument(); if(!args[4].isValid())return Argument(); if(!args[5].isValid())return Argument(); ((*object).*method)((ArgumentType_0) args[0], (ArgumentType_1) args[1], (ArgumentType_2) args[2], (ArgumentType_3) args[3], (ArgumentType_4) args[4], (ArgumentType_5) args[5]); return Argument::VoidArgument(); } Argument call(void * object, std::vector<Argument> args )const{ return typedCall(static_cast<ClassType*>(object),args); } };
  template<typename ClassType, typename ReturnType,typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7> struct TypedMethodInfo<ReturnType(ClassType::*)(A1, A2, A3, A4, A5, A6, A7) const>:public MethodInfo{ typedef ReturnType(ClassType::*MethodType)(A1, A2, A3, A4, A5, A6, A7)const ; MethodType method; typedef function_traits<MethodType> traits; typedef typename std::decay<typename traits::template arg<0>::type>::type ArgumentType_0; typedef typename std::decay<typename traits::template arg<1>::type>::type ArgumentType_1; typedef typename std::decay<typename traits::template arg<2>::type>::type ArgumentType_2; typedef typename std::decay<typename traits::template arg<3>::type>::type ArgumentType_3; typedef typename std::decay<typename traits::template arg<4>::type>::type ArgumentType_4; typedef typename std::decay<typename traits::template arg<5>::type>::type ArgumentType_5; typedef typename std::decay<typename traits::template arg<6>::type>::type ArgumentType_6; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<ReturnType>()); argumentTypes().push_back(type_of<A1>()); argumentTypes().push_back(type_of<A2>()); argumentTypes().push_back(type_of<A3>()); argumentTypes().push_back(type_of<A4>()); argumentTypes().push_back(type_of<A5>()); argumentTypes().push_back(type_of<A6>()); argumentTypes().push_back(type_of<A7>()); setIsConst(true); } Argument typedCall(const ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); if(!args[1].isValid())return Argument(); if(!args[2].isValid())return Argument(); if(!args[3].isValid())return Argument(); if(!args[4].isValid())return Argument(); if(!args[5].isValid())return Argument(); if(!args[6].isValid())return Argument(); return Argument(((*object).*method)((ArgumentType_0) args[0], (ArgumentType_1) args[1], (ArgumentType_2) args[2], (ArgumentType_3) args[3], (ArgumentType_4) args[4], (ArgumentType_5) args[5], (ArgumentType_6) args[6])); } Argument call(const void * object, std::vector<Argument> args )const{ return typedCall(static_cast<const ClassType*>(object),args); } }; template<typename ClassType, typename ReturnType,typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7> struct TypedMethodInfo<ReturnType(ClassType::*)(A1, A2, A3, A4, A5, A6, A7)>:public MethodInfo{ typedef ReturnType(ClassType::*MethodType)(A1, A2, A3, A4, A5, A6, A7); MethodType method; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<ReturnType>()); argumentTypes().push_back(type_of<A1>()); argumentTypes().push_back(type_of<A2>()); argumentTypes().push_back(type_of<A3>()); argumentTypes().push_back(type_of<A4>()); argumentTypes().push_back(type_of<A5>()); argumentTypes().push_back(type_of<A6>()); argumentTypes().push_back(type_of<A7>()); setIsConst(false); } Argument typedCall(ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); if(!args[1].isValid())return Argument(); if(!args[2].isValid())return Argument(); if(!args[3].isValid())return Argument(); if(!args[4].isValid())return Argument(); if(!args[5].isValid())return Argument(); if(!args[6].isValid())return Argument(); return Argument(((*object).*method)((ArgumentType_0) args[0], (ArgumentType_1) args[1], (ArgumentType_2) args[2], (ArgumentType_3) args[3], (ArgumentType_4) args[4], (ArgumentType_5) args[5], (ArgumentType_6) args[6])); } Argument call(void * object, std::vector<Argument> args )const{ return typedCall(static_cast<ClassType*>(object),args); } }; template<typename ClassType,typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7> struct TypedMethodInfo<void(ClassType::*)(A1, A2, A3, A4, A5, A6, A7)const>:public MethodInfo{ typedef void(ClassType::*MethodType)(A1, A2, A3, A4, A5, A6, A7)const ; MethodType method; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<void>()); argumentTypes().push_back(type_of<A1>()); argumentTypes().push_back(type_of<A2>()); argumentTypes().push_back(type_of<A3>()); argumentTypes().push_back(type_of<A4>()); argumentTypes().push_back(type_of<A5>()); argumentTypes().push_back(type_of<A6>()); argumentTypes().push_back(type_of<A7>()); setIsConst(true); } Argument typedCall(const ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); if(!args[1].isValid())return Argument(); if(!args[2].isValid())return Argument(); if(!args[3].isValid())return Argument(); if(!args[4].isValid())return Argument(); if(!args[5].isValid())return Argument(); if(!args[6].isValid())return Argument(); ((*object).*method)((ArgumentType_0) args[0], (ArgumentType_1) args[1], (ArgumentType_2) args[2], (ArgumentType_3) args[3], (ArgumentType_4) args[4], (ArgumentType_5) args[5], (ArgumentType_6) args[6]); return Argument::VoidArgument(); } Argument call(const void * object, std::vector<Argument> args )const{ return typedCall(static_cast<const ClassType*>(object),args); } }; template<typename ClassType,typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7> struct TypedMethodInfo<void(ClassType::*)(A1, A2, A3, A4, A5, A6, A7)>:public MethodInfo{ typedef void(ClassType::*MethodType)(A1, A2, A3, A4, A5, A6, A7) ; MethodType method; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<void>()); argumentTypes().push_back(type_of<A1>()); argumentTypes().push_back(type_of<A2>()); argumentTypes().push_back(type_of<A3>()); argumentTypes().push_back(type_of<A4>()); argumentTypes().push_back(type_of<A5>()); argumentTypes().push_back(type_of<A6>()); argumentTypes().push_back(type_of<A7>()); setIsConst(false); } Argument typedCall(ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); if(!args[1].isValid())return Argument(); if(!args[2].isValid())return Argument(); if(!args[3].isValid())return Argument(); if(!args[4].isValid())return Argument(); if(!args[5].isValid())return Argument(); if(!args[6].isValid())return Argument(); ((*object).*method)((ArgumentType_0) args[0], (ArgumentType_1) args[1], (ArgumentType_2) args[2], (ArgumentType_3) args[3], (ArgumentType_4) args[4], (ArgumentType_5) args[5], (ArgumentType_6) args[6]); return Argument::VoidArgument(); } Argument call(void * object, std::vector<Argument> args )const{ return typedCall(static_cast<ClassType*>(object),args); } };
  template<typename ClassType, typename ReturnType,typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8> struct TypedMethodInfo<ReturnType(ClassType::*)(A1, A2, A3, A4, A5, A6, A7, A8) const>:public MethodInfo{ typedef ReturnType(ClassType::*MethodType)(A1, A2, A3, A4, A5, A6, A7, A8)const ; MethodType method; typedef function_traits<MethodType> traits; typedef typename std::decay<typename traits::template arg<0>::type>::type ArgumentType_0; typedef typename std::decay<typename traits::template arg<1>::type>::type ArgumentType_1; typedef typename std::decay<typename traits::template arg<2>::type>::type ArgumentType_2; typedef typename std::decay<typename traits::template arg<3>::type>::type ArgumentType_3; typedef typename std::decay<typename traits::template arg<4>::type>::type ArgumentType_4; typedef typename std::decay<typename traits::template arg<5>::type>::type ArgumentType_5; typedef typename std::decay<typename traits::template arg<6>::type>::type ArgumentType_6; typedef typename std::decay<typename traits::template arg<7>::type>::type ArgumentType_7; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<ReturnType>()); argumentTypes().push_back(type_of<A1>()); argumentTypes().push_back(type_of<A2>()); argumentTypes().push_back(type_of<A3>()); argumentTypes().push_back(type_of<A4>()); argumentTypes().push_back(type_of<A5>()); argumentTypes().push_back(type_of<A6>()); argumentTypes().push_back(type_of<A7>()); argumentTypes().push_back(type_of<A8>()); setIsConst(true); } Argument typedCall(const ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); if(!args[1].isValid())return Argument(); if(!args[2].isValid())return Argument(); if(!args[3].isValid())return Argument(); if(!args[4].isValid())return Argument(); if(!args[5].isValid())return Argument(); if(!args[6].isValid())return Argument(); if(!args[7].isValid())return Argument(); return Argument(((*object).*method)((ArgumentType_0) args[0], (ArgumentType_1) args[1], (ArgumentType_2) args[2], (ArgumentType_3) args[3], (ArgumentType_4) args[4], (ArgumentType_5) args[5], (ArgumentType_6) args[6], (ArgumentType_7) args[7])); } Argument call(const void * object, std::vector<Argument> args )const{ return typedCall(static_cast<const ClassType*>(object),args); } }; template<typename ClassType, typename ReturnType,typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8> struct TypedMethodInfo<ReturnType(ClassType::*)(A1, A2, A3, A4, A5, A6, A7, A8)>:public MethodInfo{ typedef ReturnType(ClassType::*MethodType)(A1, A2, A3, A4, A5, A6, A7, A8); MethodType method; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<ReturnType>()); argumentTypes().push_back(type_of<A1>()); argumentTypes().push_back(type_of<A2>()); argumentTypes().push_back(type_of<A3>()); argumentTypes().push_back(type_of<A4>()); argumentTypes().push_back(type_of<A5>()); argumentTypes().push_back(type_of<A6>()); argumentTypes().push_back(type_of<A7>()); argumentTypes().push_back(type_of<A8>()); setIsConst(false); } Argument typedCall(ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); if(!args[1].isValid())return Argument(); if(!args[2].isValid())return Argument(); if(!args[3].isValid())return Argument(); if(!args[4].isValid())return Argument(); if(!args[5].isValid())return Argument(); if(!args[6].isValid())return Argument(); if(!args[7].isValid())return Argument(); return Argument(((*object).*method)((ArgumentType_0) args[0], (ArgumentType_1) args[1], (ArgumentType_2) args[2], (ArgumentType_3) args[3], (ArgumentType_4) args[4], (ArgumentType_5) args[5], (ArgumentType_6) args[6], (ArgumentType_7) args[7])); } Argument call(void * object, std::vector<Argument> args )const{ return typedCall(static_cast<ClassType*>(object),args); } }; template<typename ClassType,typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8> struct TypedMethodInfo<void(ClassType::*)(A1, A2, A3, A4, A5, A6, A7, A8)const>:public MethodInfo{ typedef void(ClassType::*MethodType)(A1, A2, A3, A4, A5, A6, A7, A8)const ; MethodType method; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<void>()); argumentTypes().push_back(type_of<A1>()); argumentTypes().push_back(type_of<A2>()); argumentTypes().push_back(type_of<A3>()); argumentTypes().push_back(type_of<A4>()); argumentTypes().push_back(type_of<A5>()); argumentTypes().push_back(type_of<A6>()); argumentTypes().push_back(type_of<A7>()); argumentTypes().push_back(type_of<A8>()); setIsConst(true); } Argument typedCall(const ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); if(!args[1].isValid())return Argument(); if(!args[2].isValid())return Argument(); if(!args[3].isValid())return Argument(); if(!args[4].isValid())return Argument(); if(!args[5].isValid())return Argument(); if(!args[6].isValid())return Argument(); if(!args[7].isValid())return Argument(); ((*object).*method)((ArgumentType_0) args[0], (ArgumentType_1) args[1], (ArgumentType_2) args[2], (ArgumentType_3) args[3], (ArgumentType_4) args[4], (ArgumentType_5) args[5], (ArgumentType_6) args[6], (ArgumentType_7) args[7]); return Argument::VoidArgument(); } Argument call(const void * object, std::vector<Argument> args )const{ return typedCall(static_cast<const ClassType*>(object),args); } }; template<typename ClassType,typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8> struct TypedMethodInfo<void(ClassType::*)(A1, A2, A3, A4, A5, A6, A7, A8)>:public MethodInfo{ typedef void(ClassType::*MethodType)(A1, A2, A3, A4, A5, A6, A7, A8) ; MethodType method; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<void>()); argumentTypes().push_back(type_of<A1>()); argumentTypes().push_back(type_of<A2>()); argumentTypes().push_back(type_of<A3>()); argumentTypes().push_back(type_of<A4>()); argumentTypes().push_back(type_of<A5>()); argumentTypes().push_back(type_of<A6>()); argumentTypes().push_back(type_of<A7>()); argumentTypes().push_back(type_of<A8>()); setIsConst(false); } Argument typedCall(ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); if(!args[1].isValid())return Argument(); if(!args[2].isValid())return Argument(); if(!args[3].isValid())return Argument(); if(!args[4].isValid())return Argument(); if(!args[5].isValid())return Argument(); if(!args[6].isValid())return Argument(); if(!args[7].isValid())return Argument(); ((*object).*method)((ArgumentType_0) args[0], (ArgumentType_1) args[1], (ArgumentType_2) args[2], (ArgumentType_3) args[3], (ArgumentType_4) args[4], (ArgumentType_5) args[5], (ArgumentType_6) args[6], (ArgumentType_7) args[7]); return Argument::VoidArgument(); } Argument call(void * object, std::vector<Argument> args )const{ return typedCall(static_cast<ClassType*>(object),args); } };
  template<typename ClassType, typename ReturnType,typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9> struct TypedMethodInfo<ReturnType(ClassType::*)(A1, A2, A3, A4, A5, A6, A7, A8, A9) const>:public MethodInfo{ typedef ReturnType(ClassType::*MethodType)(A1, A2, A3, A4, A5, A6, A7, A8, A9)const ; MethodType method; typedef function_traits<MethodType> traits; typedef typename std::decay<typename traits::template arg<0>::type>::type ArgumentType_0; typedef typename std::decay<typename traits::template arg<1>::type>::type ArgumentType_1; typedef typename std::decay<typename traits::template arg<2>::type>::type ArgumentType_2; typedef typename std::decay<typename traits::template arg<3>::type>::type ArgumentType_3; typedef typename std::decay<typename traits::template arg<4>::type>::type ArgumentType_4; typedef typename std::decay<typename traits::template arg<5>::type>::type ArgumentType_5; typedef typename std::decay<typename traits::template arg<6>::type>::type ArgumentType_6; typedef typename std::decay<typename traits::template arg<7>::type>::type ArgumentType_7; typedef typename std::decay<typename traits::template arg<8>::type>::type ArgumentType_8; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<ReturnType>()); argumentTypes().push_back(type_of<A1>()); argumentTypes().push_back(type_of<A2>()); argumentTypes().push_back(type_of<A3>()); argumentTypes().push_back(type_of<A4>()); argumentTypes().push_back(type_of<A5>()); argumentTypes().push_back(type_of<A6>()); argumentTypes().push_back(type_of<A7>()); argumentTypes().push_back(type_of<A8>()); argumentTypes().push_back(type_of<A9>()); setIsConst(true); } Argument typedCall(const ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); if(!args[1].isValid())return Argument(); if(!args[2].isValid())return Argument(); if(!args[3].isValid())return Argument(); if(!args[4].isValid())return Argument(); if(!args[5].isValid())return Argument(); if(!args[6].isValid())return Argument(); if(!args[7].isValid())return Argument(); if(!args[8].isValid())return Argument(); return Argument(((*object).*method)((ArgumentType_0) args[0], (ArgumentType_1) args[1], (ArgumentType_2) args[2], (ArgumentType_3) args[3], (ArgumentType_4) args[4], (ArgumentType_5) args[5], (ArgumentType_6) args[6], (ArgumentType_7) args[7], (ArgumentType_8) args[8])); } Argument call(const void * object, std::vector<Argument> args )const{ return typedCall(static_cast<const ClassType*>(object),args); } }; template<typename ClassType, typename ReturnType,typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9> struct TypedMethodInfo<ReturnType(ClassType::*)(A1, A2, A3, A4, A5, A6, A7, A8, A9)>:public MethodInfo{ typedef ReturnType(ClassType::*MethodType)(A1, A2, A3, A4, A5, A6, A7, A8, A9); MethodType method; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<ReturnType>()); argumentTypes().push_back(type_of<A1>()); argumentTypes().push_back(type_of<A2>()); argumentTypes().push_back(type_of<A3>()); argumentTypes().push_back(type_of<A4>()); argumentTypes().push_back(type_of<A5>()); argumentTypes().push_back(type_of<A6>()); argumentTypes().push_back(type_of<A7>()); argumentTypes().push_back(type_of<A8>()); argumentTypes().push_back(type_of<A9>()); setIsConst(false); } Argument typedCall(ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); if(!args[1].isValid())return Argument(); if(!args[2].isValid())return Argument(); if(!args[3].isValid())return Argument(); if(!args[4].isValid())return Argument(); if(!args[5].isValid())return Argument(); if(!args[6].isValid())return Argument(); if(!args[7].isValid())return Argument(); if(!args[8].isValid())return Argument(); return Argument(((*object).*method)((ArgumentType_0) args[0], (ArgumentType_1) args[1], (ArgumentType_2) args[2], (ArgumentType_3) args[3], (ArgumentType_4) args[4], (ArgumentType_5) args[5], (ArgumentType_6) args[6], (ArgumentType_7) args[7], (ArgumentType_8) args[8])); } Argument call(void * object, std::vector<Argument> args )const{ return typedCall(static_cast<ClassType*>(object),args); } }; template<typename ClassType,typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9> struct TypedMethodInfo<void(ClassType::*)(A1, A2, A3, A4, A5, A6, A7, A8, A9)const>:public MethodInfo{ typedef void(ClassType::*MethodType)(A1, A2, A3, A4, A5, A6, A7, A8, A9)const ; MethodType method; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<void>()); argumentTypes().push_back(type_of<A1>()); argumentTypes().push_back(type_of<A2>()); argumentTypes().push_back(type_of<A3>()); argumentTypes().push_back(type_of<A4>()); argumentTypes().push_back(type_of<A5>()); argumentTypes().push_back(type_of<A6>()); argumentTypes().push_back(type_of<A7>()); argumentTypes().push_back(type_of<A8>()); argumentTypes().push_back(type_of<A9>()); setIsConst(true); } Argument typedCall(const ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); if(!args[1].isValid())return Argument(); if(!args[2].isValid())return Argument(); if(!args[3].isValid())return Argument(); if(!args[4].isValid())return Argument(); if(!args[5].isValid())return Argument(); if(!args[6].isValid())return Argument(); if(!args[7].isValid())return Argument(); if(!args[8].isValid())return Argument(); ((*object).*method)((ArgumentType_0) args[0], (ArgumentType_1) args[1], (ArgumentType_2) args[2], (ArgumentType_3) args[3], (ArgumentType_4) args[4], (ArgumentType_5) args[5], (ArgumentType_6) args[6], (ArgumentType_7) args[7], (ArgumentType_8) args[8]); return Argument::VoidArgument(); } Argument call(const void * object, std::vector<Argument> args )const{ return typedCall(static_cast<const ClassType*>(object),args); } }; template<typename ClassType,typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9> struct TypedMethodInfo<void(ClassType::*)(A1, A2, A3, A4, A5, A6, A7, A8, A9)>:public MethodInfo{ typedef void(ClassType::*MethodType)(A1, A2, A3, A4, A5, A6, A7, A8, A9) ; MethodType method; TypedMethodInfo(MethodType method):method(method){ setOwningType(type_of<ClassType>()); setReturnType(type_of<void>()); argumentTypes().push_back(type_of<A1>()); argumentTypes().push_back(type_of<A2>()); argumentTypes().push_back(type_of<A3>()); argumentTypes().push_back(type_of<A4>()); argumentTypes().push_back(type_of<A5>()); argumentTypes().push_back(type_of<A6>()); argumentTypes().push_back(type_of<A7>()); argumentTypes().push_back(type_of<A8>()); argumentTypes().push_back(type_of<A9>()); setIsConst(false); } Argument typedCall(ClassType * object, std::vector<Argument> args)const{ if(!args[0].isValid())return Argument(); if(!args[1].isValid())return Argument(); if(!args[2].isValid())return Argument(); if(!args[3].isValid())return Argument(); if(!args[4].isValid())return Argument(); if(!args[5].isValid())return Argument(); if(!args[6].isValid())return Argument(); if(!args[7].isValid())return Argument(); if(!args[8].isValid())return Argument(); ((*object).*method)((ArgumentType_0) args[0], (ArgumentType_1) args[1], (ArgumentType_2) args[2], (ArgumentType_3) args[3], (ArgumentType_4) args[4], (ArgumentType_5) args[5], (ArgumentType_6) args[6], (ArgumentType_7) args[7], (ArgumentType_8) args[8]); return Argument::VoidArgument(); } Argument call(void * object, std::vector<Argument> args )const{ return typedCall(static_cast<ClassType*>(object),args); } };
  */

NS_END(CORE_NAMESPACE)
